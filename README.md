### [Решение](https://github.com/Cliffart44/Java_hw_3.1.2) => [домашнего задания](https://github.com/netology-code/javaqa-homeworks/tree/master/oop1#%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-2---%D1%80%D0%B0%D0%B4%D0%B8%D0%BE%D0%BC%D0%B0%D0%BD)
##### Включает также [третью (необязательную) задачу](https://github.com/netology-code/javaqa-homeworks/tree/master/oop1#%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-3-%D0%BD%D0%B5%D0%BE%D0%B1%D1%8F%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F---%D1%86%D0%B8%D0%BA%D0%BB%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F-%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D0%BA%D0%BE%D0%B4%D0%B0).
[JaCoCo](https://www.jacoco.org/jacoco/trunk/doc/counters.html) рассчитывает цикломатическую сложность метода (количество линейно независимых маршрутов через программный код) на основе количества ветвей `B` и количества точек принятия решения `D` с помощью следующего уравнения:

`v(G) = B - D + 1`

На основе статуса покрытия каждой ветви `JaCoCo` также рассчитывает покрываемую и пропущенную сложность для каждого метода. А пропущенная сложность является показателем количества тестов, недостающих для полного покрытия модуля.
Одно из применений данной статистики состоит в том, чтобы ограничивать сложность программ во время их разработки. Рекомендуется разделять модули на более мелкие всякий раз, когда цикломатическая сложность этих модулей превысит `10` (однако в некоторых случаях может быть целесообразно создавать модули со сложностью до `15`).

---
![JaCoCo Complexity Report](https://raw.githubusercontent.com/Cliffart44/Java_hw_3.1.2/master/images/Jacoco_report.png)

На иллюстрации оранжевым выделена статистика пропущенных ветвей в связке с цикломатической сложностью. Как видно, в данном случае ничего не пропущено, что говорит о полном тестовом покрытии. И хотя в проекте содержится лишь по одному тесту для методов `switchStationUp` и `switchStationDown` (при `Cxty` равном двум), они спроектированы покрывать все имеющиеся ветви.
